import { Effect } from "effect";
import type { OBSData, OBSInput, OBSFilter, OBSScene, OBSSceneItem, OBSSceneItemTransform } from "./OBSFetcher.ts";
import { TypeRegistry, UnknownKindError } from "./TypeRegistry.ts";
import { toCamelCase, generateUniqueName, formatValue, inferType } from "./utils.ts";

/**
 * Options for code generation.
 */
export interface CodeGeneratorOptions {
  /**
   * Whether to allow inline class definitions for unknown types.
   * If false, an error will be thrown for unknown types.
   * @default true
   */
  allowInlineDefinitions?: boolean;
}

/**
 * Generates TypeScript code from OBS data.
 */
export class CodeGenerator {
  private registry: TypeRegistry;
  private options: Required<CodeGeneratorOptions>;
  private inputVarNames: Map<string, string> = new Map();
  private sceneVarNames: Map<string, string> = new Map();
  private usedNames: Set<string> = new Set();
  private unknownInputs: Map<string, OBSInput> = new Map();
  private unknownFilters: Map<string, OBSFilter> = new Map();

  constructor(registry: TypeRegistry, options: CodeGeneratorOptions = {}) {
    this.registry = registry;
    this.options = {
      allowInlineDefinitions: true,
      ...options,
    };
  }

  /**
   * Generates complete TypeScript code from OBS data.
   * Returns an Effect for consistency with the rest of the codebase.
   */
  generate(data: OBSData): Effect.Effect<string, UnknownKindError> {
    return Effect.try({
      try: () => this.generateSync(data),
      catch: (error) => error as UnknownKindError,
    });
  }

  /**
   * Synchronous code generation (internal implementation).
   */
  private generateSync(data: OBSData): string {
    // Collect unknown types first
    this.collectUnknownTypes(data);

    // Generate variable names
    this.generateVariableNames(data);

    const lines: string[] = [];

    // Add header comment
    lines.push("/**");
    lines.push(" * Auto-generated from OBS configuration");
    lines.push(" * Generated by @sceneify/obs-to-code");
    lines.push(" */");
    lines.push("");

    // Add imports
    lines.push(...this.generateImports());
    lines.push("");

    // Add inline type definitions for unknown types
    if (this.unknownInputs.size > 0 || this.unknownFilters.size > 0) {
      lines.push("// ─── Inline Type Definitions ────────────────────────────────────────────────");
      lines.push("");
      lines.push(...this.generateInlineTypeDefinitions());
      lines.push("");
    }

    // Add input declarations
    if (data.inputs.length > 0) {
      lines.push("// ─── Input Declarations ─────────────────────────────────────────────────────");
      lines.push("");
      lines.push(...this.generateInputDeclarations(data.inputs));
      lines.push("");
    }

    // Add scene declarations
    if (data.scenes.length > 0) {
      lines.push("// ─── Scene Declarations ─────────────────────────────────────────────────────");
      lines.push("");
      lines.push(...this.generateSceneDeclarations(data.scenes));
      lines.push("");
    }

    // Add exports
    lines.push("// ─── Exports ────────────────────────────────────────────────────────────────");
    lines.push("");
    lines.push(...this.generateExports(data));
    lines.push("");

    return lines.join("\n");
  }

  /**
   * Collects all unknown input and filter types.
   */
  private collectUnknownTypes(data: OBSData): void {
    for (const input of data.inputs) {
      if (!this.registry.isKnownInputKind(input.kind)) {
        if (!this.options.allowInlineDefinitions) {
          throw new UnknownKindError("input", input.kind);
        }
        this.unknownInputs.set(input.kind, input);
      }

      for (const filter of input.filters) {
        if (!this.registry.isKnownFilterKind(filter.kind)) {
          if (!this.options.allowInlineDefinitions) {
            throw new UnknownKindError("filter", filter.kind);
          }
          this.unknownFilters.set(filter.kind, filter);
        }
      }
    }
  }

  /**
   * Generates unique variable names for all inputs and scenes.
   */
  private generateVariableNames(data: OBSData): void {
    // Generate input variable names
    for (const input of data.inputs) {
      const baseName = toCamelCase(input.name);
      const uniqueName = generateUniqueName(baseName, this.usedNames);
      this.inputVarNames.set(input.name, uniqueName);
      this.usedNames.add(uniqueName);
      this.registry.markInputTypeUsed(input.kind);

      // Mark filter types as used
      for (const filter of input.filters) {
        this.registry.markFilterTypeUsed(filter.kind);
      }
    }

    // Generate scene variable names
    for (const scene of data.scenes) {
      const baseName = toCamelCase(scene.name);
      const uniqueName = generateUniqueName(baseName, this.usedNames);
      this.sceneVarNames.set(scene.name, uniqueName);
      this.usedNames.add(uniqueName);
    }
  }

  /**
   * Generates the import statements.
   */
  private generateImports(): string[] {
    const lines: string[] = [];

    // Core imports
    lines.push('import { Effect } from "effect";');
    lines.push('import {');
    lines.push('  InputType,');
    lines.push('  FilterType,');
    lines.push('  Input,');
    lines.push('  Scene,');
    lines.push('  OBSSocket,');
    lines.push('  Sceneify,');
    lines.push('} from "@sceneify/core-rewrite";');

    // Sources imports
    const usedInputTypes = this.registry.getUsedInputTypes();
    const usedFilterTypes = this.registry.getUsedFilterTypes();

    if (usedInputTypes.length > 0 || usedFilterTypes.length > 0) {
      lines.push('import {');
      
      // Input types
      for (const typeName of usedInputTypes) {
        lines.push(`  ${typeName},`);
      }
      
      // Filter types
      for (const typeName of usedFilterTypes) {
        lines.push(`  ${typeName},`);
      }
      
      lines.push('} from "@sceneify/sources";');
    }

    return lines;
  }

  /**
   * Generates inline class definitions for unknown types.
   */
  private generateInlineTypeDefinitions(): string[] {
    const lines: string[] = [];

    // Generate unknown input type definitions
    for (const [kind, input] of this.unknownInputs) {
      const className = this.generateInlineInputClassName(kind);
      const settingsType = this.generateSettingsType(input.settings);
      lines.push(`class ${className} extends InputType("${kind}")<${settingsType}>() {}`);
    }

    if (this.unknownInputs.size > 0) {
      lines.push("");
    }

    // Generate unknown filter type definitions
    for (const [kind, filter] of this.unknownFilters) {
      const className = this.generateInlineFilterClassName(kind);
      const settingsType = this.generateSettingsType(filter.settings);
      lines.push(`class ${className} extends FilterType("${kind}")<${settingsType}>() {}`);
    }

    return lines;
  }

  /**
   * Generates a class name for an unknown input kind.
   */
  private generateInlineInputClassName(kind: string): string {
    return kind
      .split("_")
      .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
      .join("") + "Input";
  }

  /**
   * Generates a class name for an unknown filter kind.
   */
  private generateInlineFilterClassName(kind: string): string {
    return kind
      .split("_")
      .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
      .join("") + "Filter";
  }

  /**
   * Generates a TypeScript type definition from settings.
   */
  private generateSettingsType(settings: Record<string, unknown>): string {
    if (Object.keys(settings).length === 0) {
      return "{}";
    }

    const entries = Object.entries(settings);
    const props = entries
      .map(([key, val]) => {
        const optional = val === undefined ? "?" : "";
        return `  "${key}"${optional}: ${inferType(val)};`;
      })
      .join("\n");

    return `{\n${props}\n}`;
  }

  /**
   * Generates input declarations.
   */
  private generateInputDeclarations(inputs: OBSInput[]): string[] {
    const lines: string[] = [];

    for (const input of inputs) {
      const varName = this.inputVarNames.get(input.name)!;
      const typeName = this.getInputTypeName(input.kind);
      
      lines.push(...this.generateInputDeclaration(varName, typeName, input));
    }

    return lines;
  }

  /**
   * Generates a single input declaration.
   */
  private generateInputDeclaration(
    varName: string,
    typeName: string,
    input: OBSInput
  ): string[] {
    const lines: string[] = [];

    lines.push(`const ${varName} = Input.declare(${typeName}, {`);
    lines.push(`  name: ${formatValue(input.name)},`);

    // Settings
    if (Object.keys(input.settings).length > 0) {
      lines.push(`  settings: ${formatValue(input.settings, 1)},`);
    }

    // Filters
    if (input.filters.length > 0) {
      lines.push(`  filters: {`);
      
      for (const filter of input.filters) {
        const filterKey = toCamelCase(filter.name);
        const filterTypeName = this.getFilterTypeName(filter.kind);
        
        lines.push(`    ${filterKey}: {`);
        lines.push(`      type: ${filterTypeName},`);
        lines.push(`      name: ${formatValue(filter.name)},`);
        
        if (Object.keys(filter.settings).length > 0) {
          lines.push(`      settings: ${formatValue(filter.settings, 3)},`);
        }
        
        if (!filter.enabled) {
          lines.push(`      enabled: false,`);
        }
        
        lines.push(`    },`);
      }
      
      lines.push(`  },`);
    }

    lines.push(`});`);
    lines.push("");

    return lines;
  }

  /**
   * Gets the type name for an input kind.
   */
  private getInputTypeName(kind: string): string {
    const knownName = this.registry.getInputTypeName(kind);
    if (knownName) {
      return knownName;
    }
    return this.generateInlineInputClassName(kind);
  }

  /**
   * Gets the type name for a filter kind.
   */
  private getFilterTypeName(kind: string): string {
    const knownName = this.registry.getFilterTypeName(kind);
    if (knownName) {
      return knownName;
    }
    return this.generateInlineFilterClassName(kind);
  }

  /**
   * Generates scene declarations.
   */
  private generateSceneDeclarations(scenes: OBSScene[]): string[] {
    const lines: string[] = [];

    for (const scene of scenes) {
      const varName = this.sceneVarNames.get(scene.name)!;
      lines.push(...this.generateSceneDeclaration(varName, scene));
    }

    return lines;
  }

  /**
   * Generates a single scene declaration.
   */
  private generateSceneDeclaration(varName: string, scene: OBSScene): string[] {
    const lines: string[] = [];

    lines.push(`const ${varName} = Scene.declare({`);
    lines.push(`  name: ${formatValue(scene.name)},`);
    lines.push(`  items: {`);

    for (const item of scene.items) {
      const itemKey = toCamelCase(item.sourceName);
      const inputVarName = this.inputVarNames.get(item.sourceName);
      
      if (!inputVarName) {
        // This is a scene reference or other non-input source
        continue;
      }

      lines.push(...this.generateSceneItem(itemKey, inputVarName, item, 2));
    }

    lines.push(`  },`);
    lines.push(`});`);
    lines.push("");

    return lines;
  }

  /**
   * Generates a scene item declaration.
   */
  private generateSceneItem(
    itemKey: string,
    inputVarName: string,
    item: OBSSceneItem,
    indent: number
  ): string[] {
    const lines: string[] = [];
    const indentStr = "  ".repeat(indent);

    lines.push(`${indentStr}${itemKey}: {`);
    lines.push(`${indentStr}  source: ${inputVarName},`);

    // Transform
    const transform = this.cleanTransform(item.transform);
    if (Object.keys(transform).length > 0) {
      lines.push(`${indentStr}  transform: ${formatValue(transform, indent + 1)},`);
    }

    // Enabled state
    if (!item.sceneItemEnabled) {
      lines.push(`${indentStr}  enabled: false,`);
    }

    // Lock state
    if (item.sceneItemLocked) {
      lines.push(`${indentStr}  lock: true,`);
    }

    // Index (for ordering)
    lines.push(`${indentStr}  index: ${item.sceneItemIndex},`);

    lines.push(`${indentStr}},`);

    return lines;
  }

  /**
   * Removes undefined/null values from transform.
   */
  private cleanTransform(transform: OBSSceneItemTransform): OBSSceneItemTransform {
    const result: OBSSceneItemTransform = {};
    
    for (const [key, value] of Object.entries(transform)) {
      if (value !== undefined && value !== null) {
        (result as any)[key] = value;
      }
    }

    return result;
  }

  /**
   * Generates export statements.
   */
  private generateExports(data: OBSData): string[] {
    const exports: string[] = [];

    // Input exports
    for (const input of data.inputs) {
      const varName = this.inputVarNames.get(input.name);
      if (varName) {
        exports.push(varName);
      }
    }

    // Scene exports
    for (const scene of data.scenes) {
      const varName = this.sceneVarNames.get(scene.name);
      if (varName) {
        exports.push(varName);
      }
    }

    if (exports.length === 0) {
      return [];
    }

    return [`export { ${exports.join(", ")} };`];
  }
}
